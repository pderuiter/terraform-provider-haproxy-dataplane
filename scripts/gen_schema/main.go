package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

type resourceSpec struct {
	Name       string
	SchemaName string
	Exclude    map[string]bool
}

type genResult struct {
	SchemaCode string
	TypeCode   string
	Imports    map[string]bool
}

func main() {
	root := "."
	specPath := filepath.Join(root, "spec", "openapi.json")
	specBytes, err := os.ReadFile(specPath)
	if err != nil {
		panic(err)
	}
	loader := openapi3.NewLoader()
	spec, err := loader.LoadFromData(specBytes)
	if err != nil {
		panic(err)
	}
	if err := loader.ResolveRefsIn(spec, nil); err != nil {
		panic(err)
	}

	resources := []resourceSpec{
		{Name: "backend", SchemaName: "backend", Exclude: map[string]bool{"name": true}},
		{Name: "frontend", SchemaName: "frontend", Exclude: map[string]bool{"name": true}},
		{Name: "server", SchemaName: "server", Exclude: map[string]bool{"name": true}},
		{Name: "bind", SchemaName: "bind", Exclude: map[string]bool{"name": true}},
	}

	for _, r := range resources {
		schemaRef, ok := spec.Components.Schemas[r.SchemaName]
		if !ok {
			panic(fmt.Sprintf("schema %s not found", r.SchemaName))
		}

		res := generateObjectSchema(spec, schemaRef, r.Exclude)
		writeFile(r.Name, res)
	}

	writeRegistry(spec)
}

func writeFile(name string, res genResult) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by scripts/gen_schema. DO NOT EDIT.\n")
	buf.WriteString("package provider\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/attr\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/resource/schema\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/types\"\n")
	if res.Imports["stringvalidator"] {
		buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator\"\n")
		buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/schema/validator\"\n")
	}
	buf.WriteString(")\n\n")

	buf.WriteString(fmt.Sprintf("func %sSpecAttributes() map[string]schema.Attribute {\n", name))
	buf.WriteString("\treturn ")
	buf.WriteString(res.SchemaCode)
	buf.WriteString("\n}\n\n")

	buf.WriteString(fmt.Sprintf("func %sSpecAttrTypes() map[string]attr.Type {\n", name))
	buf.WriteString("\treturn ")
	buf.WriteString(res.TypeCode)
	buf.WriteString("\n}\n")

	outPath := filepath.Join("internal", "provider", fmt.Sprintf("gen_%s_spec.go", name))
	if err := os.WriteFile(outPath, buf.Bytes(), 0o644); err != nil {
		panic(err)
	}
}

func generateObjectSchema(spec *openapi3.T, schemaRef *openapi3.SchemaRef, exclude map[string]bool) genResult {
	schema := resolveSchema(spec, schemaRef)
	merged := mergeAllOf(spec, schema)
	props := merged.Properties

	keys := make([]string, 0, len(props))
	for k := range props {
		if exclude[k] {
			continue
		}
		keys = append(keys, k)
	}
	sort.Strings(keys)

	attrMap := make(map[string]genResult)
	imports := map[string]bool{}
	for _, k := range keys {
		prop := props[k]
		attrMap[k] = generateAttribute(spec, prop, required(merged, k))
		for imp := range attrMap[k].Imports {
			imports[imp] = true
		}
	}

	var schemaBuf bytes.Buffer
	var typeBuf bytes.Buffer

	schemaBuf.WriteString("map[string]schema.Attribute{")
	typeBuf.WriteString("map[string]attr.Type{")

	for i, k := range keys {
		if i > 0 {
			schemaBuf.WriteString(" ")
			typeBuf.WriteString(" ")
		}
		schemaBuf.WriteString(fmt.Sprintf("\"%s\": %s,", k, attrMap[k].SchemaCode))
		typeBuf.WriteString(fmt.Sprintf("\"%s\": %s,", k, attrMap[k].TypeCode))
	}

	schemaBuf.WriteString("}")
	typeBuf.WriteString("}")

	return genResult{SchemaCode: schemaBuf.String(), TypeCode: typeBuf.String(), Imports: imports}
}

func required(schema *openapi3.Schema, key string) bool {
	for _, r := range schema.Required {
		if r == key {
			return true
		}
	}
	return false
}

func generateAttribute(spec *openapi3.T, schemaRef *openapi3.SchemaRef, req bool) genResult {
	schema := resolveSchema(spec, schemaRef)
	if len(schema.AllOf) > 0 {
		schema = mergeAllOf(spec, schema)
	}

	if len(schema.OneOf) > 0 || len(schema.AnyOf) > 0 {
		return genResult{
			SchemaCode: fmt.Sprintf("schema.DynamicAttribute{Optional: %t}", !req),
			TypeCode:   "types.DynamicType",
		}
	}

	switch {
	case hasType(schema, "string"):
		return stringAttr(schema, req)
	case hasType(schema, "integer"):
		return simpleAttr("Int64", "types.Int64Type", req)
	case hasType(schema, "number"):
		return simpleAttr("Float64", "types.Float64Type", req)
	case hasType(schema, "boolean"):
		return simpleAttr("Bool", "types.BoolType", req)
	case hasType(schema, "array"):
		return arrayAttr(spec, schema, req)
	case hasType(schema, "object"):
		return objectAttr(spec, schema, req)
	default:
		return genResult{
			SchemaCode: fmt.Sprintf("schema.DynamicAttribute{Optional: %t}", !req),
			TypeCode:   "types.DynamicType",
		}
	}
}

func simpleAttr(kind, typeCode string, req bool) genResult {
	return genResult{
		SchemaCode: fmt.Sprintf("schema.%sAttribute{Optional: %t}", kind, !req),
		TypeCode:   typeCode,
	}
}

func stringAttr(schema *openapi3.Schema, req bool) genResult {
	if len(schema.Enum) > 0 {
		enums := make([]string, 0, len(schema.Enum))
		for _, v := range schema.Enum {
			if s, ok := v.(string); ok {
				enums = append(enums, s)
			}
		}
		return genResult{
			SchemaCode: fmt.Sprintf("schema.StringAttribute{Optional: %t, Validators: []validator.String{stringvalidator.OneOf(%s)}}", !req, quoteStrings(enums)),
			TypeCode:   "types.StringType",
			Imports:    map[string]bool{"stringvalidator": true},
		}
	}
	return genResult{
		SchemaCode: fmt.Sprintf("schema.StringAttribute{Optional: %t}", !req),
		TypeCode:   "types.StringType",
	}
}

func arrayAttr(spec *openapi3.T, schema *openapi3.Schema, req bool) genResult {
	if schema.Items == nil {
		return genResult{
			SchemaCode: fmt.Sprintf("schema.ListAttribute{Optional: %t, ElementType: types.DynamicType}", !req),
			TypeCode:   "types.ListType{ElemType: types.DynamicType}",
		}
	}

	item := resolveSchema(spec, schema.Items)
	if hasType(item, "object") || len(item.AllOf) > 0 {
		schemaMap, typeMap, imports := buildObjectMaps(spec, item)
		return genResult{
			SchemaCode: fmt.Sprintf("schema.ListNestedAttribute{Optional: %t, NestedObject: schema.NestedAttributeObject{Attributes: %s}}", !req, schemaMap),
			TypeCode:   fmt.Sprintf("types.ListType{ElemType: types.ObjectType{AttrTypes: %s}}", typeMap),
			Imports:    imports,
		}
	}

	itemRes := generateAttribute(spec, schema.Items, true)
	return genResult{
		SchemaCode: fmt.Sprintf("schema.ListAttribute{Optional: %t, ElementType: %s}", !req, itemRes.TypeCode),
		TypeCode:   fmt.Sprintf("types.ListType{ElemType: %s}", itemRes.TypeCode),
		Imports:    itemRes.Imports,
	}
}

func objectAttr(spec *openapi3.T, schema *openapi3.Schema, req bool) genResult {
	if schema.AdditionalProperties.Schema != nil {
		ap := resolveSchema(spec, schema.AdditionalProperties.Schema)
		if hasType(ap, "object") || len(ap.AllOf) > 0 {
			schemaMap, typeMap, imports := buildObjectMaps(spec, ap)
			return genResult{
				SchemaCode: fmt.Sprintf("schema.MapNestedAttribute{Optional: %t, NestedObject: schema.NestedAttributeObject{Attributes: %s}}", !req, schemaMap),
				TypeCode:   fmt.Sprintf("types.MapType{ElemType: types.ObjectType{AttrTypes: %s}}", typeMap),
				Imports:    imports,
			}
		}
		child := generateAttribute(spec, schema.AdditionalProperties.Schema, true)
		return genResult{
			SchemaCode: fmt.Sprintf("schema.MapAttribute{Optional: %t, ElementType: %s}", !req, child.TypeCode),
			TypeCode:   fmt.Sprintf("types.MapType{ElemType: %s}", child.TypeCode),
			Imports:    child.Imports,
		}
	}

	schemaMap, typeMap, imports := buildObjectMaps(spec, schema)
	return genResult{
		SchemaCode: fmt.Sprintf("schema.SingleNestedAttribute{Optional: %t, Attributes: %s}", !req, schemaMap),
		TypeCode:   fmt.Sprintf("types.ObjectType{AttrTypes: %s}", typeMap),
		Imports:    imports,
	}
}

func buildObjectMaps(spec *openapi3.T, schema *openapi3.Schema) (string, string, map[string]bool) {
	merged := mergeAllOf(spec, schema)
	keys := make([]string, 0, len(merged.Properties))
	for k := range merged.Properties {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	childImports := map[string]bool{}
	var schemaBuf bytes.Buffer
	var typeBuf bytes.Buffer

	schemaBuf.WriteString("map[string]schema.Attribute{")
	typeBuf.WriteString("map[string]attr.Type{")

	for i, k := range keys {
		if i > 0 {
			schemaBuf.WriteString(" ")
			typeBuf.WriteString(" ")
		}
		child := generateAttribute(spec, merged.Properties[k], required(merged, k))
		for imp := range child.Imports {
			childImports[imp] = true
		}
		schemaBuf.WriteString(fmt.Sprintf("\"%s\": %s,", k, child.SchemaCode))
		typeBuf.WriteString(fmt.Sprintf("\"%s\": %s,", k, child.TypeCode))
	}

	schemaBuf.WriteString("}")
	typeBuf.WriteString("}")

	return schemaBuf.String(), typeBuf.String(), childImports
}

func mergeAllOf(spec *openapi3.T, schema *openapi3.Schema) *openapi3.Schema {
	if len(schema.AllOf) == 0 {
		return schema
	}

	merged := &openapi3.Schema{Type: &openapi3.Types{"object"}, Properties: openapi3.Schemas{}, Required: []string{}}
	for _, ref := range schema.AllOf {
		child := resolveSchema(spec, ref)
		child = mergeAllOf(spec, child)
		for k, v := range child.Properties {
			merged.Properties[k] = v
		}
		for _, req := range child.Required {
			merged.Required = append(merged.Required, req)
		}
	}
	return merged
}

func resolveSchema(spec *openapi3.T, ref *openapi3.SchemaRef) *openapi3.Schema {
	if ref == nil {
		return &openapi3.Schema{}
	}
	if ref.Value != nil {
		return ref.Value
	}
	return &openapi3.Schema{}
}

func hasType(schema *openapi3.Schema, target string) bool {
	if schema == nil || schema.Type == nil {
		return false
	}
	for _, t := range *schema.Type {
		if t == target {
			return true
		}
	}
	return false
}

func quoteStrings(values []string) string {
	quoted := make([]string, 0, len(values))
	for _, v := range values {
		quoted = append(quoted, fmt.Sprintf("\"%s\"", strings.ReplaceAll(v, "\"", "\\\"")))
	}
	return strings.Join(quoted, ", ")
}

func writeRegistry(spec *openapi3.T) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by scripts/gen_schema. DO NOT EDIT.\n")
	buf.WriteString("package provider\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/attr\"\n")
	buf.WriteString("\tdschema \"github.com/hashicorp/terraform-plugin-framework/datasource/schema\"\n")
	buf.WriteString("\trschema \"github.com/hashicorp/terraform-plugin-framework/resource/schema\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/types\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/schema/validator\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("var schemaAttributesRegistry = map[string]map[string]rschema.Attribute{\n")
	for name, ref := range spec.Components.Schemas {
		schema := resolveSchema(spec, ref)
		if !(hasType(schema, "object") || len(schema.AllOf) > 0) {
			continue
		}
		attrRes := generateObjectSchema(spec, ref, map[string]bool{})
		schemaCode := strings.ReplaceAll(attrRes.SchemaCode, "schema.", "rschema.")
		buf.WriteString(fmt.Sprintf("\t%q: %s,\n", name, schemaCode))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("var schemaAttrTypesRegistry = map[string]map[string]attr.Type{\n")
	for name, ref := range spec.Components.Schemas {
		schema := resolveSchema(spec, ref)
		if !(hasType(schema, "object") || len(schema.AllOf) > 0) {
			continue
		}
		attrRes := generateObjectSchema(spec, ref, map[string]bool{})
		buf.WriteString(fmt.Sprintf("\t%q: %s,\n", name, attrRes.TypeCode))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("var datasourceAttributesRegistry = map[string]map[string]dschema.Attribute{\n")
	for name, ref := range spec.Components.Schemas {
		schema := resolveSchema(spec, ref)
		if !(hasType(schema, "object") || len(schema.AllOf) > 0) {
			continue
		}
		attrRes := generateObjectSchema(spec, ref, map[string]bool{})
		dsCode := strings.ReplaceAll(attrRes.SchemaCode, "schema.", "dschema.")
		buf.WriteString(fmt.Sprintf("\t%q: %s,\n", name, dsCode))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("func schemaAttributesFor(name string) (map[string]rschema.Attribute, bool) {\n")
	buf.WriteString("\tattrs, ok := schemaAttributesRegistry[name]\n")
	buf.WriteString("\treturn attrs, ok\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func schemaAttributesForDataSource(name string) (map[string]dschema.Attribute, bool) {\n")
	buf.WriteString("\tattrs, ok := datasourceAttributesRegistry[name]\n")
	buf.WriteString("\treturn attrs, ok\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func mustSchemaAttrTypes(name string) map[string]attr.Type {\n")
	buf.WriteString("\tif typesMap, ok := schemaAttrTypesRegistry[name]; ok {\n")
	buf.WriteString("\t\treturn typesMap\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn map[string]attr.Type{}\n")
	buf.WriteString("}\n")

	outPath := filepath.Join("internal", "provider", "gen_schema_registry.go")
	if err := os.WriteFile(outPath, buf.Bytes(), 0o644); err != nil {
		panic(err)
	}
}
