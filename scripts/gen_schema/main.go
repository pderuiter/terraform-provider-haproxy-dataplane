package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

type resourceSpec struct {
	Name       string
	SchemaName string
	Exclude    map[string]bool
}

type genResult struct {
	SchemaCode string
	TypeCode   string
	Imports    map[string]bool
	HasDynamic bool
}

func main() {
	root := "."
	specPath := filepath.Join(root, "spec", "openapi.json")
	specBytes, err := os.ReadFile(specPath)
	if err != nil {
		panic(err)
	}
	loader := openapi3.NewLoader()
	spec, err := loader.LoadFromData(specBytes)
	if err != nil {
		panic(err)
	}
	if err := loader.ResolveRefsIn(spec, nil); err != nil {
		panic(err)
	}

	resources := []resourceSpec{
		{Name: "backend", SchemaName: "backend", Exclude: map[string]bool{"name": true}},
		{Name: "frontend", SchemaName: "frontend", Exclude: map[string]bool{"name": true}},
		{Name: "server", SchemaName: "server", Exclude: map[string]bool{"name": true}},
		{Name: "bind", SchemaName: "bind", Exclude: map[string]bool{"name": true}},
	}

	for _, r := range resources {
		schemaRef, ok := spec.Components.Schemas[r.SchemaName]
		if !ok {
			panic(fmt.Sprintf("schema %s not found", r.SchemaName))
		}

		res := generateObjectSchema(spec, schemaRef, r.Exclude)
		writeFile(r.Name, res)
	}

	writeRegistry(spec)
}

func writeFile(name string, res genResult) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by scripts/gen_schema. DO NOT EDIT.\n")
	buf.WriteString("package provider\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/attr\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/resource/schema\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/types\"\n")
	if res.Imports["stringvalidator"] {
		buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator\"\n")
		buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/schema/validator\"\n")
	}
	buf.WriteString(")\n\n")

	buf.WriteString(fmt.Sprintf("func %sSpecAttributes() map[string]schema.Attribute {\n", name))
	buf.WriteString("\treturn ")
	buf.WriteString(res.SchemaCode)
	buf.WriteString("\n}\n\n")

	buf.WriteString(fmt.Sprintf("func %sSpecAttrTypes() map[string]attr.Type {\n", name))
	buf.WriteString("\treturn ")
	buf.WriteString(res.TypeCode)
	buf.WriteString("\n}\n")

	outPath := filepath.Join("internal", "provider", fmt.Sprintf("gen_%s_spec.go", name))
	if err := os.WriteFile(outPath, buf.Bytes(), 0o644); err != nil {
		panic(err)
	}
}

func generateObjectSchema(spec *openapi3.T, schemaRef *openapi3.SchemaRef, exclude map[string]bool) genResult {
	schema := resolveSchema(spec, schemaRef)
	merged := mergeAllOf(spec, schema)
	props := merged.Properties

	keys := make([]string, 0, len(props))
	for k := range props {
		if exclude[k] {
			continue
		}
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return tfName(keys[i]) < tfName(keys[j])
	})

	attrMap := make(map[string]genResult)
	imports := map[string]bool{}
	hasDynamic := false
	for _, k := range keys {
		prop := props[k]
		tfKey := tfName(k)
		attrMap[tfKey] = generateAttribute(spec, prop, required(merged, k))
		for imp := range attrMap[tfKey].Imports {
			imports[imp] = true
		}
		if attrMap[tfKey].HasDynamic {
			hasDynamic = true
		}
	}

	var schemaBuf bytes.Buffer
	var typeBuf bytes.Buffer

	schemaBuf.WriteString("map[string]schema.Attribute{")
	typeBuf.WriteString("map[string]attr.Type{")

	for i, k := range keys {
		if i > 0 {
			schemaBuf.WriteString(" ")
			typeBuf.WriteString(" ")
		}
		tfKey := tfName(k)
		schemaBuf.WriteString(fmt.Sprintf("\"%s\": %s,", tfKey, attrMap[tfKey].SchemaCode))
		typeBuf.WriteString(fmt.Sprintf("\"%s\": %s,", tfKey, attrMap[tfKey].TypeCode))
	}

	schemaBuf.WriteString("}")
	typeBuf.WriteString("}")

	return genResult{SchemaCode: schemaBuf.String(), TypeCode: typeBuf.String(), Imports: imports, HasDynamic: hasDynamic}
}

func required(schema *openapi3.Schema, key string) bool {
	for _, r := range schema.Required {
		if r == key {
			return true
		}
	}
	return false
}

func requiredOptional(req bool) string {
	if req {
		return "Required: true"
	}
	return "Optional: true"
}

func generateAttribute(spec *openapi3.T, schemaRef *openapi3.SchemaRef, req bool) genResult {
	schema := resolveSchema(spec, schemaRef)
	if len(schema.AllOf) > 0 {
		schema = mergeAllOf(spec, schema)
	}

	if len(schema.OneOf) > 0 || len(schema.AnyOf) > 0 {
		return genResult{
			SchemaCode: fmt.Sprintf("schema.DynamicAttribute{%s}", requiredOptional(req)),
			TypeCode:   "types.DynamicType",
			HasDynamic: true,
		}
	}

	switch {
	case hasType(schema, "string"):
		return stringAttr(schema, req)
	case hasType(schema, "integer"):
		return simpleAttr("Int64", "types.Int64Type", req)
	case hasType(schema, "number"):
		return simpleAttr("Float64", "types.Float64Type", req)
	case hasType(schema, "boolean"):
		return simpleAttr("Bool", "types.BoolType", req)
	case hasType(schema, "array"):
		return arrayAttr(spec, schema, req)
	case hasType(schema, "object"):
		return objectAttr(spec, schema, req)
	default:
		return genResult{
			SchemaCode: fmt.Sprintf("schema.DynamicAttribute{%s}", requiredOptional(req)),
			TypeCode:   "types.DynamicType",
			HasDynamic: true,
		}
	}
}

func simpleAttr(kind, typeCode string, req bool) genResult {
	return genResult{
		SchemaCode: fmt.Sprintf("schema.%sAttribute{%s}", kind, requiredOptional(req)),
		TypeCode:   typeCode,
	}
}

func stringAttr(schema *openapi3.Schema, req bool) genResult {
	if len(schema.Enum) > 0 {
		enums := make([]string, 0, len(schema.Enum))
		for _, v := range schema.Enum {
			if s, ok := v.(string); ok {
				enums = append(enums, s)
			}
		}
		return genResult{
			SchemaCode: fmt.Sprintf("schema.StringAttribute{%s, Validators: []validator.String{stringvalidator.OneOf(%s)}}", requiredOptional(req), quoteStrings(enums)),
			TypeCode:   "types.StringType",
			Imports:    map[string]bool{"stringvalidator": true},
		}
	}
	return genResult{
		SchemaCode: fmt.Sprintf("schema.StringAttribute{%s}", requiredOptional(req)),
		TypeCode:   "types.StringType",
	}
}

func arrayAttr(spec *openapi3.T, schema *openapi3.Schema, req bool) genResult {
	if schema.Items == nil {
		return genResult{
			SchemaCode: fmt.Sprintf("schema.DynamicAttribute{%s}", requiredOptional(req)),
			TypeCode:   "types.DynamicType",
			HasDynamic: true,
		}
	}

	item := resolveSchema(spec, schema.Items)
	if hasType(item, "object") || len(item.AllOf) > 0 {
		schemaMap, typeMap, imports, hasDynamic := buildObjectMaps(spec, item)
		if hasDynamic {
			return genResult{
				SchemaCode: fmt.Sprintf("schema.DynamicAttribute{%s}", requiredOptional(req)),
				TypeCode:   "types.DynamicType",
				HasDynamic: true,
			}
		}
		return genResult{
			SchemaCode: fmt.Sprintf("schema.ListNestedAttribute{%s, NestedObject: schema.NestedAttributeObject{Attributes: %s}}", requiredOptional(req), schemaMap),
			TypeCode:   fmt.Sprintf("types.ListType{ElemType: types.ObjectType{AttrTypes: %s}}", typeMap),
			Imports:    imports,
		}
	}

	itemRes := generateAttribute(spec, schema.Items, true)
	if itemRes.HasDynamic {
		return genResult{
			SchemaCode: fmt.Sprintf("schema.DynamicAttribute{%s}", requiredOptional(req)),
			TypeCode:   "types.DynamicType",
			Imports:    itemRes.Imports,
			HasDynamic: true,
		}
	}
	return genResult{
		SchemaCode: fmt.Sprintf("schema.ListAttribute{%s, ElementType: %s}", requiredOptional(req), itemRes.TypeCode),
		TypeCode:   fmt.Sprintf("types.ListType{ElemType: %s}", itemRes.TypeCode),
		Imports:    itemRes.Imports,
	}
}

func objectAttr(spec *openapi3.T, schema *openapi3.Schema, req bool) genResult {
	if schema.AdditionalProperties.Schema != nil {
		ap := resolveSchema(spec, schema.AdditionalProperties.Schema)
		if hasType(ap, "object") || len(ap.AllOf) > 0 {
			schemaMap, typeMap, imports, hasDynamic := buildObjectMaps(spec, ap)
			if hasDynamic {
				return genResult{
					SchemaCode: fmt.Sprintf("schema.DynamicAttribute{%s}", requiredOptional(req)),
					TypeCode:   "types.DynamicType",
					HasDynamic: true,
				}
			}
			return genResult{
				SchemaCode: fmt.Sprintf("schema.MapNestedAttribute{%s, NestedObject: schema.NestedAttributeObject{Attributes: %s}}", requiredOptional(req), schemaMap),
				TypeCode:   fmt.Sprintf("types.MapType{ElemType: types.ObjectType{AttrTypes: %s}}", typeMap),
				Imports:    imports,
			}
		}
		child := generateAttribute(spec, schema.AdditionalProperties.Schema, true)
		return genResult{
			SchemaCode: fmt.Sprintf("schema.MapAttribute{%s, ElementType: %s}", requiredOptional(req), child.TypeCode),
			TypeCode:   fmt.Sprintf("types.MapType{ElemType: %s}", child.TypeCode),
			Imports:    child.Imports,
		}
	}

	schemaMap, typeMap, imports, _ := buildObjectMaps(spec, schema)
	return genResult{
		SchemaCode: fmt.Sprintf("schema.SingleNestedAttribute{%s, Attributes: %s}", requiredOptional(req), schemaMap),
		TypeCode:   fmt.Sprintf("types.ObjectType{AttrTypes: %s}", typeMap),
		Imports:    imports,
	}
}

func buildObjectMaps(spec *openapi3.T, schema *openapi3.Schema) (string, string, map[string]bool, bool) {
	merged := mergeAllOf(spec, schema)
	keys := make([]string, 0, len(merged.Properties))
	for k := range merged.Properties {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return tfName(keys[i]) < tfName(keys[j])
	})

	childImports := map[string]bool{}
	hasDynamic := false
	var schemaBuf bytes.Buffer
	var typeBuf bytes.Buffer

	schemaBuf.WriteString("map[string]schema.Attribute{")
	typeBuf.WriteString("map[string]attr.Type{")

	for i, k := range keys {
		if i > 0 {
			schemaBuf.WriteString(" ")
			typeBuf.WriteString(" ")
		}
		child := generateAttribute(spec, merged.Properties[k], required(merged, k))
		for imp := range child.Imports {
			childImports[imp] = true
		}
		if child.HasDynamic {
			hasDynamic = true
		}
		tfKey := tfName(k)
		schemaBuf.WriteString(fmt.Sprintf("\"%s\": %s,", tfKey, child.SchemaCode))
		typeBuf.WriteString(fmt.Sprintf("\"%s\": %s,", tfKey, child.TypeCode))
	}

	schemaBuf.WriteString("}")
	typeBuf.WriteString("}")

	return schemaBuf.String(), typeBuf.String(), childImports, hasDynamic
}

func mergeAllOf(spec *openapi3.T, schema *openapi3.Schema) *openapi3.Schema {
	if len(schema.AllOf) == 0 {
		return schema
	}

	merged := &openapi3.Schema{Type: &openapi3.Types{"object"}, Properties: openapi3.Schemas{}, Required: []string{}}
	for _, ref := range schema.AllOf {
		child := resolveSchema(spec, ref)
		child = mergeAllOf(spec, child)
		for k, v := range child.Properties {
			merged.Properties[k] = v
		}
		for _, req := range child.Required {
			merged.Required = append(merged.Required, req)
		}
	}
	return merged
}

func resolveSchema(spec *openapi3.T, ref *openapi3.SchemaRef) *openapi3.Schema {
	if ref == nil {
		return &openapi3.Schema{}
	}
	if ref.Value != nil {
		return ref.Value
	}
	return &openapi3.Schema{}
}

func hasType(schema *openapi3.Schema, target string) bool {
	if schema == nil || schema.Type == nil {
		return false
	}
	for _, t := range *schema.Type {
		if t == target {
			return true
		}
	}
	return false
}

func quoteStrings(values []string) string {
	quoted := make([]string, 0, len(values))
	for _, v := range values {
		quoted = append(quoted, fmt.Sprintf("\"%s\"", strings.ReplaceAll(v, "\"", "\\\"")))
	}
	return strings.Join(quoted, ", ")
}

func tfName(apiName string) string {
	lower := strings.ToLower(apiName)
	var b strings.Builder
	for _, r := range lower {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '_' {
			b.WriteRune(r)
			continue
		}
		b.WriteRune('_')
	}
	out := strings.Trim(b.String(), "_")
	if out == "" {
		return "field"
	}
	return out
}

func buildObjectMeta(spec *openapi3.T, schema *openapi3.Schema) string {
	merged := mergeAllOf(spec, schema)
	keys := make([]string, 0, len(merged.Properties))
	for k := range merged.Properties {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return tfName(keys[i]) < tfName(keys[j])
	})

	var buf bytes.Buffer
	buf.WriteString("map[string]*schemaFieldMeta{")
	for i, k := range keys {
		if i > 0 {
			buf.WriteString(" ")
		}
		tfKey := tfName(k)
		metaFields := generateMeta(spec, merged.Properties[k])
		buf.WriteString(fmt.Sprintf("\"%s\": &schemaFieldMeta{APIName: %q, %s},", tfKey, k, metaFields))
	}
	buf.WriteString("}")
	return buf.String()
}

func generateMeta(spec *openapi3.T, schemaRef *openapi3.SchemaRef) string {
	schema := resolveSchema(spec, schemaRef)
	if len(schema.AllOf) > 0 {
		schema = mergeAllOf(spec, schema)
	}
	if len(schema.OneOf) > 0 || len(schema.AnyOf) > 0 {
		return `Kind: "dynamic"`
	}
	switch {
	case hasType(schema, "string"), hasType(schema, "integer"), hasType(schema, "number"), hasType(schema, "boolean"):
		return `Kind: "primitive"`
	case hasType(schema, "array"):
		if schema.Items == nil {
			return `Kind: "list", Elem: &schemaFieldMeta{Kind: "dynamic"}`
		}
		elem := generateMeta(spec, schema.Items)
		return fmt.Sprintf("Kind: \"list\", Elem: &schemaFieldMeta{%s}", elem)
	case hasType(schema, "object"):
		if schema.AdditionalProperties.Schema != nil {
			elem := generateMeta(spec, schema.AdditionalProperties.Schema)
			return fmt.Sprintf("Kind: \"map\", Elem: &schemaFieldMeta{%s}", elem)
		}
		fields := buildObjectMeta(spec, schema)
		return fmt.Sprintf("Kind: \"object\", Fields: %s", fields)
	default:
		return `Kind: "dynamic"`
	}
}

func writeRegistry(spec *openapi3.T) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by scripts/gen_schema. DO NOT EDIT.\n")
	buf.WriteString("package provider\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/attr\"\n")
	buf.WriteString("\tdschema \"github.com/hashicorp/terraform-plugin-framework/datasource/schema\"\n")
	buf.WriteString("\trschema \"github.com/hashicorp/terraform-plugin-framework/resource/schema\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/types\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator\"\n")
	buf.WriteString("\t\"github.com/hashicorp/terraform-plugin-framework/schema/validator\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("type schemaFieldMeta struct {\n")
	buf.WriteString("\tAPIName string\n")
	buf.WriteString("\tKind    string\n")
	buf.WriteString("\tFields  map[string]*schemaFieldMeta\n")
	buf.WriteString("\tElem    *schemaFieldMeta\n")
	buf.WriteString("}\n\n")

	buf.WriteString("var schemaAttributesRegistry = map[string]map[string]rschema.Attribute{\n")
	for name, ref := range spec.Components.Schemas {
		schema := resolveSchema(spec, ref)
		if !(hasType(schema, "object") || len(schema.AllOf) > 0) {
			continue
		}
		attrRes := generateObjectSchema(spec, ref, map[string]bool{})
		schemaCode := strings.ReplaceAll(attrRes.SchemaCode, "schema.", "rschema.")
		buf.WriteString(fmt.Sprintf("\t%q: %s,\n", name, schemaCode))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("var schemaAttrTypesRegistry = map[string]map[string]attr.Type{\n")
	for name, ref := range spec.Components.Schemas {
		schema := resolveSchema(spec, ref)
		if !(hasType(schema, "object") || len(schema.AllOf) > 0) {
			continue
		}
		attrRes := generateObjectSchema(spec, ref, map[string]bool{})
		buf.WriteString(fmt.Sprintf("\t%q: %s,\n", name, attrRes.TypeCode))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("var datasourceAttributesRegistry = map[string]map[string]dschema.Attribute{\n")
	for name, ref := range spec.Components.Schemas {
		schema := resolveSchema(spec, ref)
		if !(hasType(schema, "object") || len(schema.AllOf) > 0) {
			continue
		}
		attrRes := generateObjectSchema(spec, ref, map[string]bool{})
		dsCode := strings.ReplaceAll(attrRes.SchemaCode, "schema.", "dschema.")
		buf.WriteString(fmt.Sprintf("\t%q: %s,\n", name, dsCode))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("var schemaMetaRegistry = map[string]*schemaFieldMeta{\n")
	for name, ref := range spec.Components.Schemas {
		schema := resolveSchema(spec, ref)
		meta := generateMeta(spec, ref)
		if schema == nil {
			continue
		}
		buf.WriteString(fmt.Sprintf("\t%q: &schemaFieldMeta{%s},\n", name, meta))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("func schemaAttributesFor(name string) (map[string]rschema.Attribute, bool) {\n")
	buf.WriteString("\tattrs, ok := schemaAttributesRegistry[name]\n")
	buf.WriteString("\treturn attrs, ok\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func schemaAttributesForDataSource(name string) (map[string]dschema.Attribute, bool) {\n")
	buf.WriteString("\tattrs, ok := datasourceAttributesRegistry[name]\n")
	buf.WriteString("\treturn attrs, ok\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func schemaMetaFor(name string) (*schemaFieldMeta, bool) {\n")
	buf.WriteString("\tmeta, ok := schemaMetaRegistry[name]\n")
	buf.WriteString("\treturn meta, ok\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func mustSchemaAttrTypes(name string) map[string]attr.Type {\n")
	buf.WriteString("\tif typesMap, ok := schemaAttrTypesRegistry[name]; ok {\n")
	buf.WriteString("\t\treturn typesMap\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn map[string]attr.Type{}\n")
	buf.WriteString("}\n")

	outPath := filepath.Join("internal", "provider", "gen_schema_registry.go")
	if err := os.WriteFile(outPath, buf.Bytes(), 0o644); err != nil {
		panic(err)
	}
}
