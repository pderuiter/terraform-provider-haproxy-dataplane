import json
import re
from pathlib import Path

SPEC_PATH = Path('spec/openapi.json')
OUT_DIR = Path('internal/provider')

SPEC = json.load(open(SPEC_PATH))

# Utility

def singularize(segment: str) -> str:
    if segment.endswith('ies') and len(segment) > 3:
        return segment[:-3] + 'y'
    if segment.endswith('sses'):
        return segment[:-2]
    if segment.endswith('s') and not segment.endswith('ss'):
        return segment[:-1]
    return segment

def go_ident(name: str) -> str:
    parts = re.split(r'[_\-]', name)
    return ''.join(p[:1].upper() + p[1:] for p in parts if p)

def attr_go_type(param_name: str) -> str:
    if param_name == 'index':
        return 'types.Int64'
    return 'types.String'

def value_string_expr(var: str, param_name: str) -> str:
    if param_name == 'index':
        return f'int64ToString({var}.ValueInt64())'
    return f'{var}.ValueString()'

def tf_param_name(param_name: str) -> str:
    name = re.sub(r'[^a-z0-9_]', '_', param_name.lower())
    if name == 'id':
        return 'param_id'
    return name

paths = SPEC['paths']
config_paths = {p: paths[p] for p in paths if p.startswith('/services/haproxy/configuration/')}

resources = []

for path, item in config_paths.items():
    path_params = re.findall(r'\{([^}]+)\}', path)
    if not path_params:
        continue

    segments = path.rstrip('/').split('/')
    if not segments:
        continue
    collection_path = '/'.join(segments[:-1])
    if not collection_path.startswith('/services/haproxy/configuration/'):
        continue

    collection_item = config_paths.get(collection_path)
    has_post = bool(collection_item and 'post' in collection_item)
    has_put = 'put' in item
    has_delete = 'delete' in item

    def schema_info_from_op(op):
        if not op:
            return (None, False)
        rb = op.get('requestBody') or {}
        content = rb.get('content') or {}
        app = content.get('application/json') or {}
        schema = app.get('schema') or {}
        if not schema:
            return (None, False)
        if '$ref' in schema:
            name = schema['$ref'].split('/')[-1]
            sch = SPEC['components']['schemas'].get(name, {})
            if sch.get('type') == 'array':
                items = sch.get('items', {})
                if '$ref' in items:
                    return (items['$ref'].split('/')[-1], True)
                return (None, True)
            return (name, False)
        if schema.get('type') == 'array':
            items = schema.get('items', {})
            if '$ref' in items:
                return (items['$ref'].split('/')[-1], True)
            return (None, True)
        return (None, False)

    post_schema, post_is_array = schema_info_from_op(collection_item['post']) if has_post else (None, False)
    put_schema, put_is_array = schema_info_from_op(item.get('put', {})) if has_put else (None, False)
    schema_name = post_schema or put_schema
    is_array = post_is_array or put_is_array
    if not schema_name:
        continue

    rel_segments = segments[4:]
    rel_literals = [s for s in rel_segments if not s.startswith('{')]
    rel_literals = [singularize(s) for s in rel_literals]
    res_name = '_'.join(rel_literals)

    def collect_params(op):
        params = op.get('parameters') or []
        req = []
        for p in params:
            if not p.get('required'):
                continue
            if p.get('name') == 'version':
                continue
            req.append((p.get('name'), p.get('in')))
        return req

    post_params = collect_params(collection_item['post']) if has_post else []
    get_params = collect_params(item.get('get', {})) if item.get('get') else []
    put_params = collect_params(item.get('put', {})) if has_put else []
    del_params = collect_params(item.get('delete', {})) if has_delete else []

    query_params = []
    for params in (post_params, get_params, put_params, del_params):
        for name, loc in params:
            if loc != 'query':
                continue
            if name not in query_params:
                query_params.append(name)

    path_params = [p for p in path_params]

    if not has_post and not has_put:
        continue

    resources.append({
        'name': res_name,
        'path': path,
        'collection_path': collection_path,
        'schema': schema_name,
        'is_array': is_array,
        'path_params': path_params,
        'query_params': query_params,
        'create_via': 'post' if has_post else 'put',
        'has_put': has_put,
        'has_post': has_post,
        'has_delete': has_delete,
    })

seen = set()
unique = []
for r in resources:
    if r['name'] in seen:
        continue
    seen.add(r['name'])
    unique.append(r)
resources = sorted(unique, key=lambda r: r['name'])

OUT_DIR.mkdir(parents=True, exist_ok=True)

with open(OUT_DIR / 'resources_gen.go', 'w') as f:
    f.write("// Code generated by scripts/gen_resources.py. DO NOT EDIT.\n")
    f.write("package provider\n\n")
    f.write("import (\n\t\"github.com/hashicorp/terraform-plugin-framework/resource\"\n)\n\n")
    f.write("func generatedResources() []func() resource.Resource {\n\treturn []func() resource.Resource{\n")
    for r in resources:
        f.write(f"\t\tNew{go_ident(r['name'])}Resource,\n")
    f.write("\t}\n}\n")

for r in resources:
    name = r['name']
    type_name = go_ident(name)
    path_params = r['path_params']
    query_params = r['query_params']
    is_array = r['is_array']

    fields = []
    for p in path_params + query_params:
        tf_name = tf_param_name(p)
        go_type = attr_go_type(p)
        fields.append((go_ident(tf_name), go_type, tf_name, p))

    param_schema_lines = []
    for p in path_params + query_params:
        attr_type = 'String' if p != 'index' else 'Int64'
        param_schema_lines.append(f"\t\t\t\"{tf_param_name(p)}\": schema.{attr_type}Attribute{{Required: true}},\n")

    def query_lines(var_prefix: str):
        lines = []
        for p in query_params:
            field = go_ident(tf_param_name(p))
            lines.append(f"\t\t\t\"{p}\": []string{{{value_string_expr(var_prefix+field, p)}}},\n")
        return lines

    def path_lines(var_prefix: str):
        lines = []
        for p in path_params:
            field = go_ident(tf_param_name(p))
            lines.append(f"\t\t\t\"{p}\": {value_string_expr(var_prefix+field, p)},\n")
        return lines

    id_parts = [f"{value_string_expr('plan.'+go_ident(tf_param_name(p)), p)}" for p in path_params + query_params]
    id_expr = '"/".join([])' if not id_parts else 'strings.Join([]string{' + ', '.join(id_parts) + '}, "/")'

    drop_keys = [f"\"{p}\"" for p in path_params if p in ['name', 'index']]
    drop_keys_str = '[]string{' + ', '.join(drop_keys) + '}'

    with open(OUT_DIR / f'gen_resource_{name}.go', 'w') as f:
        f.write("// Code generated by scripts/gen_resources.py. DO NOT EDIT.\n")
        f.write("package provider\n\n")
        f.write("import (\n\t\"context\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/hashicorp/terraform-plugin-framework/resource\"\n\t\"github.com/hashicorp/terraform-plugin-framework/resource/schema\"\n\t\"github.com/hashicorp/terraform-plugin-framework/types\"\n\t\"github.com/pderuiter/terraform-provider-haproxy-dataplane/internal/client\"\n)\n\n")
        f.write(f"var _ resource.Resource = (*{name}Resource)(nil)\n\n")
        f.write(f"func New{type_name}Resource() resource.Resource {{\n\treturn &{name}Resource{{}}\n}}\n\n")
        f.write(f"type {name}Resource struct {{\n\tclient *client.Client\n}}\n\n")
        f.write(f"type {name}Model struct {{\n\tID types.String `tfsdk:\"id\"`\n")
        for field, go_type, tf_name, _ in fields:
            f.write(f"\t{field} {go_type} `tfsdk:\"{tf_name}\"`\n")
        if is_array:
            f.write("\tSpec types.Dynamic `tfsdk:\"spec\"`\n}\n\n")
        else:
            f.write("\tSpec types.Object `tfsdk:\"spec\"`\n}\n\n")

        f.write(f"func (r *{name}Resource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {{\n\tresp.TypeName = req.ProviderTypeName + \"_{name}\"\n}}\n\n")
        f.write(f"func (r *{name}Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {{\n")
        if not is_array:
            f.write("\tattrs, ok := schemaAttributesFor(\"%s\")\n" % r['schema'])
            f.write("\tif !ok {\n\t\tresp.Diagnostics.AddError(\"Schema not found\", \"%s\")\n\t\treturn\n\t}\n" % r['schema'])
            if path_params:
                f.write("\tfor _, k := range []string{")
                f.write(", ".join([f"\"{tf_param_name(p)}\"" for p in path_params]))
                f.write("} {\n\t\tdelete(attrs, k)\n\t}\n")
        f.write("\tresp.Schema = schema.Schema{\n\t\tAttributes: map[string]schema.Attribute{\n")
        f.write("\t\t\t\"id\": schema.StringAttribute{Computed: true},\n")
        for line in param_schema_lines:
            f.write(line)
        if is_array:
            f.write("\t\t\t\"spec\": schema.DynamicAttribute{Required: true},\n")
        else:
            f.write("\t\t\t\"spec\": schema.SingleNestedAttribute{Required: true, Attributes: attrs},\n")
        f.write("\t\t},\n\t}\n}\n\n")

        f.write(f"func (r *{name}Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {{\n")
        f.write("\tif req.ProviderData == nil {\n\t\treturn\n\t}\n")
        f.write("\tclient, diags := getClient(req.ProviderData)\n\tresp.Diagnostics.Append(diags...)\n\tif resp.Diagnostics.HasError() {\n\t\treturn\n\t}\n\tif client != nil {\n\t\tr.client = client\n\t}\n}\n\n")

        # Create
        f.write(f"func (r *{name}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {{\n")
        f.write(f"\tvar plan {name}Model\n\tresp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)\n\tif resp.Diagnostics.HasError() {{\n\t\treturn\n\t}}\n")
        if is_array:
            f.write("\tpayload, diags := dynamicToObjectsWithSchema(ctx, plan.Spec, \"%s\")\n" % r['schema'])
            f.write("\tresp.Diagnostics.Append(diags...)\n\tif resp.Diagnostics.HasError() {\n\t\treturn\n\t}\n")
        else:
            f.write("\tpayload, diags := objectToMapWithSchema(ctx, plan.Spec, \"%s\")\n" % r['schema'])
            f.write("\tresp.Diagnostics.Append(diags...)\n\tif resp.Diagnostics.HasError() {\n\t\treturn\n\t}\n")
            for p in path_params:
                if p in ['name', 'index']:
                    field = go_ident(tf_param_name(p))
                    f.write(f"\tpayload[\"{p}\"] = {value_string_expr('plan.'+field, p)}\n")
        create_path = r['collection_path'] if r['create_via'] == 'post' else r['path']
        f.write("\tpath := buildPath(\"%s\", map[string]string{\n" % create_path)
        for line in path_lines('plan.'):
            f.write(line)
        f.write("\t})\n")
        if r['create_via'] == 'post':
            f.write("\tif err := applyWithVersionRetry(ctx, r.client, func(version int64) error {\n")
            f.write("\t\tquery := url.Values{\n\t\t\t\"version\": []string{int64ToString(version)},\n")
            for line in query_lines('plan.'):
                f.write(line.replace("\t\t\t", "\t\t\t"))
            f.write("\t\t}\n")
            f.write("\t\treturn r.client.PostJSON(ctx, path, query, payload, nil)\n\t}); err != nil {\n\t\tresp.Diagnostics.AddError(\"Create failed\", err.Error())\n\t\treturn\n\t}\n")
        else:
            f.write("\tif err := applyWithVersionRetry(ctx, r.client, func(version int64) error {\n")
            f.write("\t\tquery := url.Values{\n\t\t\t\"version\": []string{int64ToString(version)},\n")
            for line in query_lines('plan.'):
                f.write(line.replace("\t\t\t", "\t\t\t"))
            f.write("\t\t}\n")
            f.write("\t\treturn r.client.PutJSON(ctx, path, query, payload, nil)\n\t}); err != nil {\n\t\tresp.Diagnostics.AddError(\"Create failed\", err.Error())\n\t\treturn\n\t}\n")
        f.write(f"\tplan.ID = types.StringValue({id_expr})\n")
        f.write("\tresp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)\n}\n\n")

        # Read
        f.write(f"func (r *{name}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {{\n")
        f.write(f"\tvar state {name}Model\n\tresp.Diagnostics.Append(req.State.Get(ctx, &state)...)\n\tif resp.Diagnostics.HasError() {{\n\t\treturn\n\t}}\n")
        f.write("\tquery := url.Values{\n")
        for line in query_lines('state.'):
            f.write(line)
        f.write("\t}\n")
        f.write("\tpath := buildPath(\"%s\", map[string]string{\n" % r['path'])
        for line in path_lines('state.'):
            f.write(line)
        f.write("\t})\n")
        if is_array:
            f.write("\tvar out []map[string]any\n\tif err := r.client.GetJSON(ctx, path, query, &out); err != nil {\n\t\tif client.IsNotFound(err) {\n\t\t\tresp.State.RemoveResource(ctx)\n\t\t\treturn\n\t\t}\n\t\tresp.Diagnostics.AddError(\"Read failed\", err.Error())\n\t\treturn\n\t}\n")
            f.write("\tresp.Diagnostics.Append(resp.State.Set(ctx, &state)...)\n}\n\n")
        else:
            f.write("\tvar out map[string]any\n\tif err := r.client.GetJSON(ctx, path, query, &out); err != nil {\n\t\tif client.IsNotFound(err) {\n\t\t\tresp.State.RemoveResource(ctx)\n\t\t\treturn\n\t\t}\n\t\tresp.Diagnostics.AddError(\"Read failed\", err.Error())\n\t\treturn\n\t}\n")
            f.write("\tresp.Diagnostics.Append(resp.State.Set(ctx, &state)...)\n}\n\n")

        # Update
        f.write(f"func (r *{name}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {{\n")
        f.write(f"\tvar plan {name}Model\n\tresp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)\n\tif resp.Diagnostics.HasError() {{\n\t\treturn\n\t}}\n")
        if r['has_put']:
            if is_array:
                f.write("\tpayload, diags := dynamicToObjectsWithSchema(ctx, plan.Spec, \"%s\")\n" % r['schema'])
                f.write("\tresp.Diagnostics.Append(diags...)\n\tif resp.Diagnostics.HasError() {\n\t\treturn\n\t}\n")
            else:
                f.write("\tpayload, diags := objectToMapWithSchema(ctx, plan.Spec, \"%s\")\n" % r['schema'])
                f.write("\tresp.Diagnostics.Append(diags...)\n\tif resp.Diagnostics.HasError() {\n\t\treturn\n\t}\n")
                for p in path_params:
                    if p in ['name', 'index']:
                        field = go_ident(tf_param_name(p))
                        f.write(f"\tpayload[\"{p}\"] = {value_string_expr('plan.'+field, p)}\n")
            f.write("\tpath := buildPath(\"%s\", map[string]string{\n" % r['path'])
            for line in path_lines('plan.'):
                f.write(line)
            f.write("\t})\n")
            f.write("\tif err := applyWithVersionRetry(ctx, r.client, func(version int64) error {\n")
            f.write("\t\tquery := url.Values{\n\t\t\t\"version\": []string{int64ToString(version)},\n")
            for line in query_lines('plan.'):
                f.write(line.replace("\t\t\t", "\t\t\t"))
            f.write("\t\t}\n")
            f.write("\t\treturn r.client.PutJSON(ctx, path, query, payload, nil)\n\t}); err != nil {\n\t\tresp.Diagnostics.AddError(\"Update failed\", err.Error())\n\t\treturn\n\t}\n")
            f.write(f"\tplan.ID = types.StringValue({id_expr})\n")
            f.write("\tresp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)\n")
        elif r['has_post']:
            if is_array:
                f.write("\tpayload, diags := dynamicToObjectsWithSchema(ctx, plan.Spec, \"%s\")\n" % r['schema'])
                f.write("\tresp.Diagnostics.Append(diags...)\n\tif resp.Diagnostics.HasError() {\n\t\treturn\n\t}\n")
            else:
                f.write("\tpayload, diags := objectToMapWithSchema(ctx, plan.Spec, \"%s\")\n" % r['schema'])
                f.write("\tresp.Diagnostics.Append(diags...)\n\tif resp.Diagnostics.HasError() {\n\t\treturn\n\t}\n")
                for p in path_params:
                    if p in ['name', 'index']:
                        field = go_ident(tf_param_name(p))
                        f.write(f"\tpayload[\"{p}\"] = {value_string_expr('plan.'+field, p)}\n")
            f.write("\tpath := buildPath(\"%s\", map[string]string{\n" % r['collection_path'])
            for line in path_lines('plan.'):
                f.write(line)
            f.write("\t})\n")
            f.write("\tif err := applyWithVersionRetry(ctx, r.client, func(version int64) error {\n")
            f.write("\t\tquery := url.Values{\n\t\t\t\"version\": []string{int64ToString(version)},\n")
            for line in query_lines('plan.'):
                f.write(line.replace("\t\t\t", "\t\t\t"))
            f.write("\t\t}\n")
            f.write("\t\treturn r.client.PostJSON(ctx, path, query, payload, nil)\n\t}); err != nil {\n\t\tresp.Diagnostics.AddError(\"Update failed\", err.Error())\n\t\treturn\n\t}\n")
            f.write(f"\tplan.ID = types.StringValue({id_expr})\n")
            f.write("\tresp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)\n")
        f.write("}\n\n")

        # Delete
        f.write(f"func (r *{name}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {{\n")
        f.write(f"\tvar state {name}Model\n\tresp.Diagnostics.Append(req.State.Get(ctx, &state)...)\n\tif resp.Diagnostics.HasError() {{\n\t\treturn\n\t}}\n")
        if r['has_delete']:
            f.write("\tpath := buildPath(\"%s\", map[string]string{\n" % r['path'])
            for line in path_lines('state.'):
                f.write(line)
            f.write("\t})\n")
            f.write("\tif err := applyWithVersionRetry(ctx, r.client, func(version int64) error {\n")
            f.write("\t\tquery := url.Values{\n\t\t\t\"version\": []string{int64ToString(version)},\n")
            for line in query_lines('state.'):
                f.write(line.replace("\t\t\t", "\t\t\t"))
            f.write("\t\t}\n")
            f.write("\t\treturn r.client.DeleteJSON(ctx, path, query, nil)\n\t}); err != nil {\n\t\tif client.IsNotFound(err) {\n\t\t\treturn\n\t\t}\n\t\tresp.Diagnostics.AddError(\"Delete failed\", err.Error())\n\t\treturn\n\t}\n")
        f.write("}\n\n")

        f.write(f"var _ resource.ResourceWithConfigure = (*{name}Resource)(nil)\n")

print(f"Generated {len(resources)} resources")
